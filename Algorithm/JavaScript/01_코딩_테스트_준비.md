# 01 코딩 테스트 준비

## 코딩 테스트에 대비한 마음가짐
1. 다른 사람의 풀이 참고해보기
2. 아는 것과 모르는 것을 명확하게 구분하기
    - 문제에 대해 기록하기, 문제를 풀지 못하더라도 어디까지 생각했는지 기록하기
    - 시험 보듯이 제한 시간을 두고 문제 풀기
    - 내가 공부한 개념을 나만의 언어로 요약하기
3. 입력 데이터, 자료구조, 알고리즘을 이해하기
    - 문제 유형: 첫 번째 유형을 제외하면 모두 입력 데이터, 자료구조, 알고리즘에 대한 이해 필요함
        1. 분기, 반복 사용하는 단순 절차 문제
        2. 특정 자료구조를 사용해야 효율적인 문제
        3. 빠른 성능을 위해 이미 연구된 알고리즘을 사용하는 문제
        4. 특정 사고방식으로 접근해야 하는 문제
    - 자료구조와 알고리즘은 현실을 컴퓨터 관점에서 이해하기 위한 도구
    - 컴퓨터를 더 이해하는 공부를 한다고 생각하면 더 의미있게 공부할 수 있음
    - 요구사항을 구현하기 위해서는 알고리즘에 대한 이해가 필요함

## 코딩 테스트 효율적으로 준비하기
### 문제 분석 연습하기
1. 전체 시간의 50-60%는 문제 분석에 시간을 투자하기
2. 문제를 쪼개서 분석하기
3. 제약 사항을 파악하고 테스트 케이스를 적절하게 추가하기
4. 입력값을 분석하기
5. 문제의 핵심 키워드를 파악하기
	- 스택: 쌍이 맞는지, 최근
	- 큐: 순서대로, ~대로 동작, 스케줄링, 최소 시간
	- DFS: 모든 경로
	- BFS: 최적, 레벨 순회, 최소 단계, 네트워크 전파
	- 백트래킹: 조합, 순열, 부분 집합
	- 최단 경로: 최단 경로, 최소 시간, 최소 비용, 트래픽, 음의 순환, 단일 출발점 경로
6. 데이터 흐름이나 구성을 파악 (자료 구조 선택을 위해)

### 의사 코드로 설계하는 연습하기
- 의사 코드: 프로그램의 논리를 설명하고 알고리즘을 표현하기 위해 작성하는 지침
	- 프로그래밍 언어가 아닌 자연어로 자유롭게 작성
	- 실제 구현 단계 전 추상 단계에서 작성
1. 세부 구현이 아닌 동작 중심으로 작성하기 (프로그래밍적 요소 배제)
2. 문제 해결 순서대로 작성하기 (실제 코드의 주석이 된다고 생각하고 작성)
3. 구현하기 전에 충분히 테스트하기 (구현 단계에서 에러 수정을 하는 것이 더 어려움)


# 02 알고리즘의 효율 분석
## 시간 복잡도
- 알고리즘의 성능을 나타내는 지표
- 입력 크기에 대한 연산 횟수의 상한
- 낮을 수록 좋음
### 빅오 표기법
- 최악의 경우에 대한 시간 복잡도를 표현함
- 최고 차항만 남기고 지움
	- 지수 > n제곱 > 1차 > 로그
	- 가능한 이유: 데이터 x가 커질 수록 나머지 항은 무시 가능할 정도로 작아짐
### 시간 복잡도를 코딩 테스트에 활용하는 방법
 - 빅오 표기법을 활용해서 해당 알고리즘을 적용했을 때 제한 시간 내에 출력값이 나올 수 있을지 확인하기
 - 기준: 컴퓨터가 초당 연산할 수 있는 최대 횟수는 1억
 - 실제 적용 기준: 초당 연산 횟수 약 1,000-2,000만
	 - ex) 제한 시간이 1초인 문제는 연산 횟수가 2,000만이 넘는 알고리즘을 사용하면 안 됨
- 시간 복잡도에 따른 최대 연산 횟수(초당)
	- O(n!): 10
	- O(2ⁿ): 20-25
	- O(n³): 200-300
	- O(n²): 3,000-5,000
	- O(nlogn): 100만
	- O(n): 1,000-2,000만
	- O(logn): 10억
- 만약 제한시간 1초, 데이터 1000만개면 O(n)을 사용해야 한다고 판단할 수 있음

## 시간 복잡도 계산해보기
### 박테리아 수명 문제
- 초기 박테리아 세포 개수가 n일 때 해마다 세포 개수가 이전 세포 개수의 절반으로 줄어듦
- 언제 모든 박테리아가 죽을지 계산하기
- 풀이: 박테리아의 소멸 시기 a는 (1/2)ª * n < 1인 시점
- (1/2)ª < 1/n ⇒ 2ª > n ⇒ a > logn
- ∴ O(logn)
	- 이 문제처럼 특정 값을 반으로 줄이는 동작의 시간 복잡도는 O(logn)


# 03 코딩 테스트 필수 문법
## 빌트인 데이터 타입
### 자바스크립트의 빌트인 데이터 타입
- 원시 타입: 숫자, 문자열, 불리언 등
- 참조 타입: 오브젝트 등

## 숫자
- 자연수, 정수, 실수, 무한 모두 number로 정의함
- a = `13`, b = `4`일 때를 가정
### 숫자 타입 산술 연산 (빌트인 함수)
- Math.abs(): 절대값
- Math.ceil(): 올림
- Math.floor(): 내림
- Math.round(): 반올림 
- Math.trunc(): 버림
- Math.pow(a, b): a의 b승
### 숫자 타입 비트 연산
- a & b: AND (`4`)
- a | b: OR (`13`)
- a ^ b: XOR (`9`)
- ~a: NOT (`-14`)
- a << 2: 왼쪽 시프트, a에 2²를 곱함 (`52`)
- a >> 1: 오른쪽 시프트, a를 2¹로 나눔 (`6`)
### 숫자 타입 논리 연산
- a && b: 논리 연산 AND (`4`)
- a || b: 논리 연산 OR (`13`)
- !a: 논리 연산 NOT (`false`)
### 숫자 타입 예외
- 잘못 연산했을 때 `Infitiniy` 혹은 `NaN`이 출력될 수 있음
- a / 0: `Infinity`
- a % 0: `NaN`
- a / "str": `NaN`
- a % "str": `NaN`
- a / null: `Infinity`
- a % null: `NaN`
- a / undefined: `NaN`
- a % undefined: `NaN`
### 부동소수점 문제
- 예를 들어 10 % 3.2의 결과값은 0.4가 아닌 0.39999999..47로 표현됨
- 이유: 자바스크립트가 부동소수점 데이터를 이진법으로 표현하기 때문
- 이 과정에서 생기는 오차를 입실론이라고 함
- 만약 코딩 테스트에서 부동소수점을 다룰 일이 생겼을 때 입실론을 항상 고려해야 함
- 부동소수점 데이터를 활용하는 문제에서는 오차 허용 범위를 언급하는 경우가 많음 (꼭 체크하기)

## 문자열
### 여러 줄 만들기
- 백틱 사용
```js
const a = `
*
**
***
`;
```
### 문자열 타입 연산
- a = `"Hello"`, b=`"World"`일 때를 가정
- a + b: 문자열 (`"HelloWorld"`)
- a + 123: 문자열 (`"Hello123"`)
- a + true: 문자열("`Hellotrue"`)
### 문자열 타입 빌트인 메서드
- a = "Hello!World"일 때를 가정
- a.split("!"): 구분자로 나눔 (`["Hello", "World"]`)
- a.startsWith("Hello"): 특정 문자열로 시작하는지 확인 (`true`)
- a.endsWith("World"): 특정 문자열로 끝나는지 확인 (`true`)
- a.includes("!W"): 특정 문자열을 포함하는지 확인 (`true`)
- a.indexOf("World"): 특정 문자열의 시작 위치 확인 (`6`)
- a.lastIndexOf("l"): 특정 문자열의 마지막 위치 확인 (`9`)
- a.replace("World", "JavaScript"): 특정 문자열을 다른 문자열로 대테 (`"Hello!JavaScript"`)
- a.toUpperCase(): 대문자로 변환 (`"HELLO!WORLD"`)
- a.toLowerCase(): 소문자로 변환 (`"hello!world"`)
- a.trim(): 양쪽 공백 제거 (`"Hello!World"`)
- a.concat("?"): 문자열 연결 (`"Hello!World?"`)

## 그 외 타입
### bigint
- 큰 수를 다룰 때 사용
- 사용 방법
	1. 숫자 뒤에 n을 붙임: `111111111111111111n`
	2. BigInt():  `BigInt(111111111111111111)`
- bigint와 number을 연산하려 하면 에러가 발생함

## 참조 타입
### 원시 타입의 동작 방식
- 메모리에 저장되는 값: 원시 타입의 값 자체
- 변수에 원시 타입을 할당하면 새 메모리 주소에 값을 할당함
- 값을 변경하면 기존 메모리 주소의 값이 변경되는 것이 아니라 새 메모리 주소에 할당함
- 복사를 하면 값을 복사해 새 메모리 주소에 할당함
```js
let vari = 123; // 메모리에 값 할당
let vari2 = vari; // 메모리에 동일 값을 할당
vari = 456; // 새로운 메모리에 값 할당
console.log(vari); // 456
console.log(vari2); // 123
```
### 참조 타입의 동작 방식
- 스택 메모리에 저장되는 값: 참조 타입 값을 가리키는 메모리 주소
- 변수에 참조 타입을 할당하면 스택 메모리에 메모리 주소를 저장함
- 값을 변경하면 기존 스택 메모리 주소에 저장된 메모리 주소를 변경함
- 복사를 하면 메모리 주소를 복사한 후 스택 메모리에 저장된 메모리 주소를 변경함
```js
let vari = [1, 2]; // 스택 메모리에 메모리 주소 할당
let vari2 = vari; // 스택 메모리에 동일 메모리 주소 할당
vari = [3, 4]; // 스택 메모리에 메모리 주소 변경
console.log(vari); // [1, 2]
console.log(vari2); // [1, 2]
```

## 오브젝트
 - obj = `{ name: "chopinoff", age: 29 }`일 때를 가정
### 오브젝트 접근
- obj.name
- obj['age']: 